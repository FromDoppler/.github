name: Java 17 Service CI

on:
  workflow_call:
    inputs:
      dockerfile-path:
        description: "Path to Dockerfile to use for build image"
        default: "Dockerfile"
        type: string
      docker-image-name:
        description: "The name of the docker image to delivery"
        required: true
        type: string
      service-name:
        description: "The name of the service to deploy"
        required: true
        type: string
      include-redis-package:
        description: "Download shared Redis package"
        required: false
        default: false
        type: boolean
      kafka-packages-release-tag:
        description: "Release tag for Kafka shared package"
        default: "v1.0.0"
        type: string
      base-packages-release-tag:
        description: "Release tag for Base shared package"
        default: "v1.0.0"
        type: string
      api-graph-packages-release-tag:
        description: "Release tag for API Graph SDK shared package"
        default: "v1.0.0"
        type: string
      redis-packages-release-tag:
        description: "Release tag for Redis shared package"
        default: "v1.0.1"
        type: string

env:
  TZ: America/Argentina/Jujuy
  MAVEN_USER_HOME: ${{ github.workspace }}/.maven
  NAMESPACE_QA: beplic-qa
  NAMESPACE_PROD: beplic-prod
  KAFKA_REPO_NAME: doppler-conversations-generic-kafka-lib
  KAFKA_PACKAGES_RELEASE_TAG: ${{ inputs.kafka-packages-release-tag }}
  BASE_REPO_NAME: doppler-conversations-base-lib
  BASE_PACKAGES_RELEASE_TAG: ${{ inputs.base-packages-release-tag }}
  API_GRAPH_REPO_NAME: doppler-conversations-api-graph-sdk-lib
  API_GRAPH_PACKAGES_RELEASE_TAG: ${{ inputs.api-graph-packages-release-tag }}
  REDIS_REPO_NAME: doppler-conversations-generic-redis-lib
  REDIS_PACKAGES_RELEASE_TAG: ${{ inputs.redis-packages-release-tag }}
  GH_OWNER: FromDoppler
  SOURCE_VERSION: "${{ github.ref_name }}+${{ github.sha }}@${{ github.server_url}}/${{ github.repository }}"
  IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/${{ inputs.docker-image-name }}
  SERVICE: ${{ inputs.service-name }}
  DEPLOY_REF: ${{ github.ref_type == 'tag' && github.ref_name || github.head_ref || github.ref_name }}

jobs:
  # sonarqube:
  #   if: github.ref == 'refs/heads/qa'
  #   runs-on: ubuntu-latest
  #   permissions:
  #     contents: read
  #   continue-on-error: true
  #   env:
  #     SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
  #     SONAR_USER_HOME: ${{ runner.temp }}/.sonar
  #   steps:
  #     - name: Checkout
  #       uses: actions/checkout@v4
  #       with:
  #         fetch-depth: 0

  #     - name: Set up Java 17
  #       uses: actions/setup-java@v4
  #       with:
  #         distribution: temurin
  #         java-version: "17"
  #         cache: maven

  #     - name: Cache SonarQube files
  #       uses: actions/cache@v4
  #       with:
  #         path: ${{ env.SONAR_USER_HOME }}/cache
  #         key: sonar-${{ runner.os }}-${{ hashFiles('**/pom.xml') }}
  #         restore-keys: |
  #           sonar-${{ runner.os }}-

  #     - name: Prepare Maven wrapper
  #       run: chmod +x mvnw

  #     - name: Run SonarQube analysis (tests skipped)
  #       run: ./mvnw -ntp verify sonar:sonar -Dmaven.test.skip=true

  maven-package:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: "17"
          cache: maven

      - name: Ensure Maven repository folder exists
        run: mkdir -p "$MAVEN_USER_HOME"

      - name: Cache custom Maven repository
        uses: actions/cache@v4
        with:
          path: ${{ env.MAVEN_USER_HOME }}
          key: maven-${{ runner.os }}-${{ hashFiles('**/pom.xml') }}
          restore-keys: |
            maven-${{ runner.os }}-

      - name: Prepare Maven wrapper
        run: chmod +x mvnw

      - name: Download shared GitHub packages
        env:
          GH_TOKEN: ${{ secrets.GH_PACKAGES_TOKEN }}
          INCLUDE_REDIS_PACKAGE: ${{ inputs.include-redis-package }}
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${GH_TOKEN:-}" ]]; then
            echo "GH_PACKAGES_TOKEN secret is required to download external libraries." >&2
            exit 1
          fi

          download_package() {
            local repo_name=$1
            local label=$2
            local release_tag=$3
            local repo="${GH_OWNER}/${repo_name}"
            local target_dir="external-libs/${repo_name}"

            echo "Descargando release ${release_tag} de ${repo} (${label})"
            mkdir -p "${target_dir}"
            if ! gh release download \
              "${release_tag}" \
              --repo "${repo}" \
              --pattern '*.zip' \
              --pattern '*.jar' \
              --dir "${target_dir}"; then
              echo "No se pudo descargar assets de release para ${repo}" >&2
              exit 1
            fi

            shopt -s nullglob
            for file in "${target_dir}"/*.zip; do
              echo "Descomprimiendo ${file}"
              unzip_dir="${target_dir}/unzipped/$(basename "${file}" .zip)"
              mkdir -p "${unzip_dir}"
              unzip -o "${file}" -d "${unzip_dir}"

              mapfile -t maven_dirs < <(find "${unzip_dir}" -type d \( -name ".maven" -o -name ".m2" \))
              if (( ${#maven_dirs[@]} == 0 )); then
                echo "No se encontrÃ³ carpeta .maven/.m2 dentro de ${file};" >&2
              else
                for mdir in "${maven_dirs[@]}"; do
                  echo "Sincronizando repo Maven desde ${mdir} hacia ${MAVEN_USER_HOME}"
                  mkdir -p "${MAVEN_USER_HOME}"
                  cp -R "${mdir}/." "${MAVEN_USER_HOME}/"
                done
              fi
            done
            for file in "${target_dir}"/*.jar; do
              echo "Copiando ${file} a ${MAVEN_USER_HOME}"
              cp "${file}" "${MAVEN_USER_HOME}/"
            done
            shopt -u nullglob
          }

          download_package "${KAFKA_REPO_NAME}" "POC Generic Kafka" "${KAFKA_PACKAGES_RELEASE_TAG}"
          download_package "${BASE_REPO_NAME}" "Beplic Base" "${BASE_PACKAGES_RELEASE_TAG}"
          download_package "${API_GRAPH_REPO_NAME}" "Beplic API Graph SDK" "${API_GRAPH_PACKAGES_RELEASE_TAG}"
          if [[ "${INCLUDE_REDIS_PACKAGE}" == "true" ]]; then
            download_package "${REDIS_REPO_NAME}" "Generic Redis" "${REDIS_PACKAGES_RELEASE_TAG}"
          else
            echo "Redis package not requested; skipping"
          fi

      - name: Build with Maven
        run: |
          ./mvnw -ntp compile -Dmaven.repo.local=$MAVEN_USER_HOME -DskipTests
          ./mvnw -ntp verify -Pdev -DskipTests -Dmaven.repo.local=$MAVEN_USER_HOME

      - name: Build and deploy
        uses: actions/upload-artifact@v4
        with:
          name: maven-package
          path: |
            target/*.jar
            target/classes
            target/generated-sources
          if-no-files-found: error
          retention-days: 1

  docker-hub:
    name: Docker image to Docker Hub
    runs-on: ubuntu-latest
    needs:
      - maven-package
    env:
      REGISTRY: docker.io
      IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/${{ inputs.docker-image-name }}
    steps:
      - name: Check out the repo
        uses: actions/checkout@v4

      - name: Download package artifacts
        uses: actions/download-artifact@v4
        with:
          name: maven-package
          path: .
      - name: Flatten downloaded artifacts
        shell: bash
        run: |
          set -euo pipefail
          if [[ -d "maven-package" ]]; then
            shopt -s dotglob
            cp -R maven-package/* .
            shopt -u dotglob
          fi
      - name: Ensure jar in target for Docker build
        shell: bash
        run: |
          set -euo pipefail
          jar_path=$(
            find . \
              \( -path "./target/*.jar" \
                -o -path "./maven-package/target/*.jar" \
                -o -path "./*.jar" \
                -o -path "./maven-package/*.jar" \) \
              ! -name "*.original" \
              ! -name "maven-wrapper.jar" \
              | head -n1
          )
          if [[ -z "${jar_path}" ]]; then
            echo "No JAR found in downloaded artifacts." >&2
            find . -maxdepth 3 -type f -name "*.jar" >&2 || true
            exit 1
          fi
          mkdir -p target
          cp "${jar_path}" "target/$(basename "${jar_path}")"
          echo "Jar prepared at target/$(basename "${jar_path}")"

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Extract metadata (tags, labels) for Docker
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.IMAGE_NAME }}
          tags: |
            type=semver,pattern={{raw}}
            type=semver,pattern=v{{version}}
            type=semver,pattern=v{{major}}.{{minor}}
            type=semver,pattern=v{{major}}
            type=ref,event=branch
      - name: Build and push Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ${{ inputs.dockerfile-path }}
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          build-args: |
            version=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ env.SOURCE_VERSION }}
            FROMDOPPLER_GITHUB_PACKAGES_TOKEN=${{ secrets.GITHUB_TOKEN }}

  deploy-qa:
    runs-on: ubuntu-latest
    needs:
      - docker-hub
    if: github.ref == 'refs/heads/main'
    environment:
      name: qa
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Save DigitalOcean kubeconfig with short-lived credentials
        run: |
          doctl kubernetes cluster kubeconfig save \
          --expiry-seconds 600 ${{ secrets.CONVERSATIONS_CLUSTER_NAME }}

      - name: Rollout to QA cluster
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${SERVICE}" ]]; then
            echo "La variable SERVICE es obligatoria." >&2
            exit 1
          fi
          for service in ${SERVICE}; do
            echo "Actualizando ${service} en ${NAMESPACE_QA}"
            kubectl set image \
              "deploy/${service}" \
              "${service}=${{ env.IMAGE_NAME }}:${{ github.ref_name }}" \
              --namespace "${NAMESPACE_QA}"
            kubectl rollout status deploy/${service} -n ${NAMESPACE_QA}
          done

  deploy-prod:
    runs-on: ubuntu-latest
    needs:
      - docker-hub
    if: github.ref_type == 'tag'
    environment:
      name: prod
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Save DigitalOcean kubeconfig with short-lived credentials
        run: |
          doctl kubernetes cluster kubeconfig save \
          --expiry-seconds 600 ${{ secrets.CONVERSATIONS_CLUSTER_NAME }}

      - name: Rollout to prod cluster
        shell: bash
        run: |
          set -euo pipefail
          if [[ -z "${SERVICE}" ]]; then
            echo "La variable SERVICE es obligatoria." >&2
            exit 1
          fi
          for service in ${SERVICE}; do
            echo "Actualizando ${service} en ${NAMESPACE_PROD}"
            kubectl set image \
              "deploy/${service}" \
              "${service}=${{ env.IMAGE_NAME }}:${{ github.ref_name }}" \
              --namespace "${NAMESPACE_PROD}"
            kubectl rollout status deploy/${service} -n ${NAMESPACE_PROD}
          done
